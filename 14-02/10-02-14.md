### Finished assignment 3 cse 202

### Reading Forward Query Processor
Understand the query processor as it is today and how it relates to the abstract query optimization we have been doing up to now. We goover chapters
8 to 13 quickly. Next we go over the normal forms and what romain has been working on.

####Plan Execution
  - We use a mediator architecture. There are two mediators, on the client and and server respectively.
  	- Server Mediator : contains schema for server-side sources (memory and relational data).
    - Client Mediator : contains universal mediator schema that cover all sources (a server is a source) from the client. It translate input queries into data access calls to the service and/or web services.
  - The wrapper model :
    - physical interface
    - plan execution algorithm
    - data model mapping 

####Action Language
 - inspired from PL/SQL
 - used to show that Forward is like extending SQL and stored procedures to websites.
 
####Querying Schemaless sources
 - We offer a unified query access of all sources (including schemaless and non-relational data sources).
 - The query processor can compile and generate physical plans when the data is schemaless or absent.
   - Part of semantic checking is deferred at compilation.
   - The rest is done dynamically, when data at execution is present.

### Review of Data Access Paper

#### SQL++ Data Model
 - SQL++ object is composed of an id and a value.
   - The id can be named (written explicitely in queries) or unnamed.
   - The object can be :
     - *typed atomic value*, e.g. 'abc', 1, 12:00:01GMT...
     - *object reference*, which is the id to some other object or null.
     - *tuple* [a1 : v1, ..., an : vn] where attribute names a1,...,an are strings and attribute values v1,...,vn are SQL++ values.
     - *expression* {e1...en}, where each ei is an SQL++ value.
 - A relation R in SQL will be an SQL++ object with :
   - as name, a named id R.
   - as value, a collection C of tuple values, such that each tuple attribute name is a column name of the original relation, and each attribute value is an atomic value corresponding to the original record cell in R.
 - Java Objects can be wrapped easily :
   - as name, the name of the java variable representing the object (or some randomly generated id for implicitely defined variables in Java).
   - as value, a collection which represents the attributes of the Java Object. In the case of lists and arrays, the collection can represent the list itself.
 - JSON can be modelled by SQL++, using
   - names for JSON keys.
   - values for JSON values.
     - atomic values for JSON terminal values.
     - tuple values for JSON arrays.
     - expression values for JSON nested maps.

#### SQL++ Language
 - Backwards compatible with SQL.
 - Has extensions over SQL :
   - 
 
#### Algebra Overview
 - A logical plan p = T1 <- e1;...;Tn <- en is a list of assignments of expressions to temporaries.
 - Each ei is SQL++ expression.  

### Come up with normal form for the query processor
 - 
 - Find if it is doable to add the new rules in.
 
### Distributed Aggregation Rewriter Implementation
Objective : Find a way to insert the newly found rewriting rules as a new query rewriter in the query processor code.
 - where in the query processing pipeline do we want to insert the rewriter.
 - what form of query should the query rewriter expect as input.
 - what form of query should it output.


### Summary from Kian Win and Romain's meeting :
 - We focus on equality-based selections :
 	- Selections are the most selective type of operations that can be pushed at a source.
 	- Selections based on equality are the most common types of selections.
 	- We assume selection predicates are written in conjunctive normal forms.
 - Focus on equality predicates for selection push down.
 - Existing configurations for equality function : 
 	- complex
 	- type mismatch
 	- nulls
 	- missings
 	- null_missing
 - Feature dependence : 
    - Each rewriting can add or remove features. 
 	
####Questions remaining
 - Dimensions equality selection rewriting rules :
   - configurations (mentionned above) : there must be a rewriting rule for each configuration.
   - order (which order should rewriting rules be in) : can rewriting rules be applied in a deterministic order?
   - source-specific : should rewriting rules be source specific or source agnostic.
   - comparisons : comparisons can be between :
     - two variables
     - a variable and a literal
     - two literals
   - features : clearly show which feature can be added/removed between each rewriting rule.
   - Need to formalize the rewriters

   
##Plan of presentation

 - Present how we want to implement selection pushdown ; using two selections :
   - P_S : selection pushed to source. 
   - P_{\bar{S}} : selection that could not be pushed to source.  
 - Show on one example how we would wish to decompose the query. The example should involve all possible rewriting rules.
   - complex equality
   - type mismatch equality
   - variable to null equality
   - variable to missing equality
   - missing to null equality (recall that missing happens when path navigation fails)
 - Any predicate pushed down to the source should not result in failure, as this could prevent valid tuples to be processed by the middleware.
   - Rule of thumb : the selection at the source should return an error *if and only if* the same error is returned when the selection is processed at the middleware. 
 - Parenthesis : Method presented here may not be easily applicable to CQL (CQL disallows any comparisons that isn't between two scalars).
 - All of the examples are written in SQL++. The conversion from SQL++ to the source language is the responsibility of the source wrapper.
 - Note that we do not look at the Hive '<=>' and JSONiq 'deep-equal' operators. We assume that the source wrapper will choose the most appropriate operator when translating SQL++ into Hive or JSONiq syntax. 
   - Example : A comparison between complex values `a=b` in SQL++ would be translate into `deep-equal(a,b);` in JSONiq. 


### Query Rewriters
We now present the different rewriters used for selection equality. For each rewriter, we present its behavior when 1) comparing a variable with a literal, 2) comparing  a variable with another variable. Note that comparing two literals can be reduced to 1) by aliasing the first literal (plus it doesn't really make sense).  

###Complexity Rewriter
Fact sheet :

 - Reduces complex equality to its minimum using atomic predicates
 - Introduces path navigation.
 - Assumes paths are accessible.
 - Assumes types are correctly matched.
 
It is assumed that most (if not all) sources are able to compare scalar values of the same type. The complex rewriter simplifies
equality between complex values by using path navigation to compare values. 

#### Variable compared with literal 

Sample input :

	user.profile = 
	{ 	name : 'Jules Testard',
		age : 22,
		birthdate : 21/10/1991,
		address : {
			mumber : 3420,
			street : 'Lebon Drive',
			apartment : '3204',
			zipcode : 92122,
			state : 'California'
		}
		phoneNumbers : [
			0607588079
			8589979311
		],
		hobbies : {{
			{ 	
				'category' : 'sport',
				'occupation' : 'surfing'
			}
		}},
		chatHistory : (
			timestamp('1014-03-12T20:00:00') : 'Hello!',
			timestamp('1014-03-12T20:00:39') : 'How are you today?',
		)
	}


Sample output :

	user.profile.name = 'Jules Testard' AND
	user.profile.age = 22 AND
	user.profile.birthdate = 21/10/1991 AND
	user.profile.address.number = 3420 AND 
	user.profile.address.street = 'Lebon Drive' AND 
	user.profile.address.apartment = '3204' AND 
	user.profile.address.zipcode = 92122 AND
	user.profile.address.state = 'California' AND
	user.profile.attrs() = {{'number','street','apartment','zipcode','state'}} --bound check  
	user.profile.phoneNumbers[1] = 0607588079 AND
	user.profile.phoneNumbers[2] = 8589979311 AND
	user.profile.phoneNumbers[3] = missing AND --bound check
	user.profile.hobbies = {{ {'category' : 'sport','occupation' : 'surfing'} }} AND 
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:00') = 'Hello!' AND
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:39') = 'How are you today?' AND
	user.profile.chatHistory.key_set() = {{ timestamp('1014-03-12T20:00:00'), timestamp('1014-03-12T20:00:39') }} AND --bound check
	user.profile.attrs() = {{ 'name', 'age', 'birthdate', 'address', 'phoneNumbers', 'hobbies', 'chatHistory' }} --bound check
 
#### Variable compared with variable 

Assume the following query :

	SELECT U1.user
	FROM S.users AS U1, S.users AS U2
	WHERE U1.user.profile.address = U2.user.profile.address 

Option 1 :
Assuming that the source relation is a closed type and a schema is available, then path navigation can be used according to the schema :

	U1.user.profile.address.number = U2.user.profile.address.number AND 
	U1.user.profile.address.street = U2.user.profile.address.street AND 
	U1.user.profile.address.apartment = U2.user.profile.address.apartment AND 
	U1.user.profile.address.zipcode = U2.user.profile.address.apartment AND
	U1.user.profile.address.state = U2.user.profile.address.apartment

Notice that the bound check is not required given the closed type assumption.  

Option 2 :

Yield and let the middleware handle this type of equality. 

### Type checking rewriter
Fact sheet :
 
 - Introduces type checks and only execute comparisons if types match.
 - Assumes paths are accessible.
 - Assumes elements are either scalars or bags (because arrays, maps and tuples can be navigated as shown above).
 
####Variable compared with literal

 - Each navigation which should evaluate to a scalar (literal is a scalar) will be type-checked
 - Each navigation which should evaluate to a bag is not type-checked. Reasons :
   - Type checking of a bag cannot be accurate because of lack of navigation within bags.

Sample input :

	user.profile.name = 'Jules Testard' AND
	user.profile.age = 22 AND
	user.profile.birthdate = 21/10/1991 AND
	user.profile.phoneNumbers[1] = 0607588079 AND
	user.profile.phoneNumbers[2] = 8589979311 AND
	user.profile.phoneNumbers[3] = missing AND
	user.profile.hobbies = {{ {'category' : 'sport','occupation' : 'surfing'} }} AND 
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:00') = 'Hello!' AND
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:39') = 'How are you today?' AND
	user.profile.chatHistory.key_set() = {{ timestamp('1014-03-12T20:00:00'), timestamp('1014-03-12T20:00:39') }} AND
	user.profile.attrs() = {{ 'name', 'age', 'birthdate', 'phoneNumbers', 'hobbies', 'chatHistory' }}
	
Sample output

	user.profile.name.
	user.profile.name = 'Jules Testard' AND
	user.profile.age = 22 AND
	user.profile.birthdate = 21/10/1991 AND
	user.profile.phoneNumbers[1] = 0607588079 AND
	user.profile.phoneNumbers[2] = 8589979311 AND
	user.profile.phoneNumbers[3] = missing AND
	user.profile.hobbies = {{ {'category' : 'sport','occupation' : 'surfing'} }} AND 
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:00') = 'Hello!' AND
	user.profile.chatHistory-> timestamp('1014-03-12T20:00:39') = 'How are you today?' AND
	user.profile.chatHistory.key_set() = {{ timestamp('1014-03-12T20:00:00'), timestamp('1014-03-12T20:00:39') }} AND
	user.profile.attrs() = {{ 'name', 'age', 'birthdate', 'phoneNumbers', 'hobbies', 'chatHistory' }}


###Path Navigation Rewriter


Rewriting procedures for batched bindings (or query batching) is a technique developed for the DBridge project  \cite{karthik-ramachandra:2015aa,mahendra-chavan:2011aa,karthik-ramachandra:2011aa,ravindra-guravannavar:2008aa} at IIT Bombay, which attempts to improve database application performance by automatically converting application code fragments exhibiting a parameter-at-a-time execution pattern into fragments exhibiting the set-at-a-time execution pattern.

Guravannavar \cite{ravindra-guravannavar:2008aa} made the following key observation: given that database application programs displaying a parameter-at-a-time execution pattern can be rewritten into a set-at-a-time execution manually, automating this process through program transformation would improve performance of parameter-at-a-time execution code. While Guravannavar focused on database stored procedures, Ramachandra \cite{karthik-ramachandra:2011aa} extended this techniques to Java programs using JDBC \cite{jdbc}.

What he proposes is a source-to-source transformation to rewrite parameter-at-a-time fragments into set-at-a-time fragments, in order to guarantee a more efficient execution. There are, however, limitations to such rewritings, in particular in the presence of side-effects. Guravannavar defines the fragments is able to transform as \emph{batch-safe}. A fragment is said to be batch-safe if the fragment's return value and the system state, for any parameter, are independent from the order in which the parameters are processed.

The transformation process then happens in two steps :
\begin{enumerate}
\item{\emph{Analyze the code fragment} : If the sequence of statements $ss$ in the loop is such that 1) it can be split into two consecutive sub-sequences $ss1$ and $ss2$ such that $ss = ss1 + ss2$ and 2) there are no loop-carried flow/output dependencies \footnote{A loop carried flow (or output) dependency $s_a \rightarrow s_b$ exists if $s_a$ writes a location on iteration $i$, while $s_b$ reads (or writes) from that location on iteration $j$ (where $i < j$).} from any statement in $ss2$ to any statement in $ss$ or the loop predicate, then $ss1$ and $ss2$ can be split into two separate loops. In our example, $ss1$ and $ss2$ correspond to lines 9-10 and 11-13 of figure \ref{fig:code1}, respectively. Loop-carried flow dependencies can be derived from an application program using a \emph{data dependence graph}. The Soot analysis framework \cite{soot} available for Java can produce such a graph.}
\item{\emph{Transform the code fragment}: once the fragment has been identified and validated, it is transformed into the program on figure \ref{fig:loopfission}, in which $ss1$ and $ss2$ are split into two loops.  The responsibility of the first loop is to collect parameters and add them to a \emph{batch table}, whose contents correspond to those of the \texttt{SelectedNations} table from Section 2 when the loop terminates. On line 14, the \texttt{executeBatch()} statement performs the set-oriented execution, by shipping the batch table to the database. On lines 15-20, the second loop's role is to collect the values from the set at a time computations and add them to the sumTotals list in the same order as the original fragment. Finally the \texttt{LoopContextTable} allows the iteration order from the first loop to be preserved in the second loop.}
\end{enumerate}

While this technique converts efficiently fragments which exhibit the parameter-at-a-time pattern, it is limited to code fragments situation where the data-source can supported set-oriented execution, which is not the case, for example, of many web services.
Moreover, the rewriting can only be applied when the initial code fragment is batch-safe, and a small modification (such as side-effecting operation modifying the system state) can violate the conditions for transformations and disable the optimization opportunity. An alternative researchers have explored consists to send multiple queries asynchronously and later retrieved the results \cite{ramachandra:2012aa, manjhi:2009aa}. 


